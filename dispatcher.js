// Generated by CoffeeScript 1.9.2
var async;

async = require('odo-async');

module.exports = function(subscriptions, hub) {
  var _fin, loadsaga, res, sagas;
  _fin = false;
  sagas = {};
  loadsaga = function(saga) {
    var instancecontext;
    return instancecontext = {
      messages: {},
      timeouts: {},
      intervals: {},
      every: function(messagekey, cb) {}
    };
  };
  res = {
    register: function(url, module, cb) {
      var sagacontext, tasks;
      sagacontext = {
        subscriptions: {},
        module: module
      };
      tasks = [];
      return module.saga({
        map: function(messagekey, fn) {
          return tasks.push(function(cb) {
            if (sagacontext.subscriptions[messagekey] != null) {
              return;
            }
            subscriptions.subscribe(messagekey);
            sagacontext.subscriptions[messagekey] = true;
            console.log(url + " subscribed to " + messagekey);
            return cb();
          });
        },
        ready: function() {
          return async.series(tasks, function() {
            console.log("configured " + url);
            sagas[url] = sagacontext;
            if (cb != null) {
              return cb();
            }
          });
        }
      });
    },
    deregister: function(url, cb) {
      var _, messagekey, ref;
      console.log("removing " + url);
      if (sagas[url] != null) {
        ref = sagas[url].subscriptions;
        for (messagekey in ref) {
          _ = ref[messagekey];
          subscriptions.unsubscribe(messagekey);
        }
        delete sagas[url];
      }
      if (cb != null) {
        return cb();
      }
    },
    onmessage: function(log, item, cb) {
      log.messagetombstones[item.message.msgid] = true;
      return cb(true);
    },
    ontimeout: function(log, item, cb) {
      delete log.timeouts[item.timeoutkey];
      log.timeouttombstones[item.timeoutkey] = true;
      return cb(true);
    },
    oninterval: function(log, item, cb) {
      log.intervals[item.intervalkey].value = item.value;
      return cb(true);
    },
    end: function(cb) {
      var _, fn1, tasks, url;
      if (_fin) {
        if (cb != null) {
          cb();
        }
        return;
      }
      tasks = [];
      fn1 = function(url) {
        return tasks.push(function(cb) {
          return res.deregister(url, cb);
        });
      };
      for (url in sagas) {
        _ = sagas[url];
        fn1(url);
      }
      return async.series(tasks, function() {
        _fin = true;
        if (cb != null) {
          return cb();
        }
      });
    }
  };
  return res;
};
