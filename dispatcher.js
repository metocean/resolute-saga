// Generated by CoffeeScript 1.9.2
var LOG, async;

async = require('odo-async');

LOG = require('./parser');

module.exports = function(subscriptions, hub) {
  var _fin, buildcontext, res, sagas;
  _fin = false;
  sagas = {};
  buildcontext = function(url, sagakey, log) {
    var updates;
    updates = LOG.blank();
    return {
      setTimeout: function(key, timeout) {
        if (!LOG.isValidKey(key)) {
          console.error("" + url + sagakey + " cannot set timeout " + key + " - bad characters");
          return;
        }
        return updates.timeouts[key] = timeout;
      },
      clearTimeout: function(key) {
        return updates.timeouttombstones[key] = true;
      },
      setInterval: function(key, anchor, count, unit, value) {
        if (!LOG.isValidKey(key)) {
          console.error("" + url + sagakey + " cannot set interval " + key + " - bad characters");
          return;
        }
        return updates.intervals[key] = {
          anchor: anchor,
          count: count,
          unit: unit,
          value: value
        };
      },
      clearInterval: function(key) {
        return updates.intervaltombstones[key] = true;
      },
      clearMessage: function(key) {
        return updates.messagetombstones[key] = true;
      },
      set: function(key, value) {
        if (!LOG.isValidKey(key)) {
          console.error("" + url + sagakey + " cannot set data " + key + " - bad characters");
          return;
        }
        return updates.data[key] = value;
      },
      get: function(key) {
        return log.data[key];
      },
      apply: function() {
        var _, interval, key, ref, ref1, ref2, ref3, ref4, ref5, results, timeout, value;
        ref = updates.messagetombstones;
        for (key in ref) {
          _ = ref[key];
          log.messagetombstones[key] = true;
        }
        ref1 = updates.timeouttombstones;
        for (key in ref1) {
          _ = ref1[key];
          log.timeouttombstones[key] = true;
          delete log.timeouts[key];
        }
        ref2 = updates.intervaltombstones;
        for (key in ref2) {
          _ = ref2[key];
          log.intervaltombstones[key] = true;
          delete log.intervals[key];
        }
        ref3 = updates.timeouts;
        for (key in ref3) {
          timeout = ref3[key];
          delete log.timeouttombstones[key];
          log.timeouts[key] = timeout;
        }
        ref4 = updates.intervals;
        for (key in ref4) {
          interval = ref4[key];
          log.intervals[key] = interval;
        }
        ref5 = updates.data;
        results = [];
        for (key in ref5) {
          value = ref5[key];
          results.push(log.data[key] = value);
        }
        return results;
      }
    };
  };
  res = {
    register: function(onmessage, url, module, cb) {
      var saga, tasks;
      saga = {
        subscriptions: {},
        module: module
      };
      tasks = [];
      return module.saga({
        map: function(messagekey, fn) {
          if (!LOG.isValidKey(messagekey)) {
            console.error(url + " cannot subscribe to " + messagekey + " - bad characters");
            return;
          }
          return tasks.push(function(cb) {
            if (saga.subscriptions[messagekey] != null) {
              return;
            }
            subscriptions.subscribe(messagekey);
            saga.subscriptions[messagekey] = true;
            saga.messagehandle = hub.every(messagekey, function(e, cb) {
              var sagakey;
              sagakey = fn(e);
              return onmessage(url, sagakey, messagekey, e, cb);
            });
            console.log(url + " subscribed to " + messagekey);
            return cb();
          });
        },
        ready: function() {
          return async.series(tasks, function() {
            console.log("configured " + url);
            sagas[url] = saga;
            if (cb != null) {
              return cb();
            }
          });
        }
      });
    },
    deregister: function(url, cb) {
      var _, messagekey, ref;
      console.log("removing " + url);
      if (sagas[url] != null) {
        ref = sagas[url].subscriptions;
        for (messagekey in ref) {
          _ = ref[messagekey];
          subscriptions.unsubscribe(messagekey);
        }
        sagas[url].messagehandle.off();
        delete sagas[url];
      }
      if (cb != null) {
        return cb();
      }
    },
    onmessage: function(log, item, cb) {
      var context, fin, instance, saga;
      if (sagas[item.url] == null) {
        console.error("Saga " + item.url + " not registered");
        return cb(true);
      }
      saga = sagas[item.url];
      context = buildcontext(item.url, item.sagakey, log);
      context.clearMessage(item.message.id);
      instance = saga.module.instance(context);
      fin = function(success) {
        if (!success) {
          return cb(false);
        }
        context.apply();
        return cb(true);
      };
      if (instance[item.messagekey] == null) {
        console.error("No handler for " + item.url + item.sagakey + " message " + item.messagekey);
        return fin(true);
      }
      return instance[item.messagekey](item.message.data, fin);
    },
    ontimeout: function(log, item, cb) {
      var context, fin, instance, saga;
      if (sagas[item.url] == null) {
        console.error("Saga " + item.url + " not registered");
        return cb(true);
      }
      saga = sagas[item.url];
      context = buildcontext(item.url, item.sagakey, log);
      context.clearTimeout(item.timeoutkey);
      instance = saga.module.instance(context);
      fin = function(success) {
        if (!success) {
          return cb(false);
        }
        context.apply();
        return cb(true);
      };
      if (instance[item.timeoutkey] == null) {
        console.error("No handler for " + item.url + item.sagakey + " timeout " + item.timeoutkey);
        return fin(true);
      }
      return instance[item.timeoutkey](item, fin);
    },
    oninterval: function(log, item, cb) {
      var context, fin, instance, saga;
      if (sagas[item.url] == null) {
        console.error("Saga " + item.url + " not registered");
        return cb(true);
      }
      saga = sagas[item.url];
      context = buildcontext(item.url, item.sagakey, log);
      context.setInterval(item.intervalkey, item.anchor, item.count, item.unit, item.value);
      instance = saga.module.instance(context);
      fin = function(success) {
        if (!success) {
          return cb(false);
        }
        context.apply();
        return cb(true);
      };
      if (instance[item.intervalkey] == null) {
        console.error("No handler for " + item.url + item.sagakey + " interval " + item.intervalkey);
        return fin(true);
      }
      return instance[item.intervalkey](item, fin);
    },
    end: function(cb) {
      var _, fn1, tasks, url;
      if (_fin) {
        if (cb != null) {
          cb();
        }
        return;
      }
      tasks = [];
      fn1 = function(url) {
        return tasks.push(function(cb) {
          return res.deregister(url, cb);
        });
      };
      for (url in sagas) {
        _ = sagas[url];
        fn1(url);
      }
      return async.series(tasks, function() {
        _fin = true;
        if (cb != null) {
          return cb();
        }
      });
    }
  };
  return res;
};
