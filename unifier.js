// Generated by CoffeeScript 1.9.2
var Queue, iso8601;

Queue = require('seuss-backoff');

iso8601 = require('./iso8601');

module.exports = function(sagalog, sagalock, options) {
  var commit, ontask, open, queue;
  ontask = options.ontask;
  open = function(item, message, cb) {
    return sagalock.acquire(item.url, item.sagakey, function(success) {
      if (!success) {
        console.log(message('COULD NOT LOCK'));
        return cb(false, null);
      }
      return sagalog.get(item.url, item.sagakey, function(err, log) {
        if (err != null) {
          console.log(message('UNABLE TO COMPLETE READ'));
          return sagalock.release(item.url, item.sagakey, function() {
            return cb(false, null);
          });
        }
        return cb(true, log);
      });
    });
  };
  commit = function(item, log, message, cb) {
    return sagalog.set(item.url, item.sagakey, log, function(err) {
      return sagalock.release(item.url, item.sagakey, function(success) {
        if (err != null) {
          if (success) {
            console.log(message('UNABLE TO COMPLETE WRITE, RELEASED LOCK ANYWAY'));
          } else {
            console.log(message('UNABLE TO COMPLETE WRITE, UNABLE TO RELEASE LOCK'));
          }
          return cb(false);
        }
        if (success) {
          console.log(message('WRITTEN TO LOG'));
        } else {
          console.log(message('WRITTEN TO LOG, UNABLE TO RELEASE LOCK'));
        }
        return cb(true);
      });
    });
  };
  queue = Queue({
    onitem: function(item, cb) {
      var alreadyseenin, isfutureevent, log, message;
      if (item.type === 'message') {
        message = function(msg) {
          return "" + item.url + item.sagakey + " MESSAGE " + item.messagekey + "#" + item.message.msgid + " " + msg;
        };
        alreadyseenin = function(log) {
          if (log.messagetombstones[item.message.msgid] != null) {
            console.log(message('ALREADY SEEN'));
            return true;
          }
          return false;
        };
        log = sagalog.getoutdated(item.url, item.sagakey);
        if (alreadyseenin(log)) {
          return cb(true);
        }
        return open(item, message, function(success, log) {
          if (!success) {
            return cb(false);
          }
          if (alreadyseenin(log)) {
            return sagalock.release(item.url, item.sagakey, function() {
              return cb(true);
            });
          }
          log.messagetombstones[item.message.msgid] = true;
          return commit(item, log, message, cb);
        });
      } else if (item.type === 'timeout') {
        message = function(msg) {
          return "" + item.url + item.sagakey + " TIMEOUT " + item.timeoutkey + "@" + (item.value.format(iso8601)) + " " + msg;
        };
        alreadyseenin = function(log) {
          if (log.timeouttombstones[item.timeoutkey] != null) {
            console.log(message('TOMBSTONED'));
            return true;
          }
          return false;
        };
        log = sagalog.getoutdated(item.url, item.sagakey);
        if (alreadyseenin(log)) {
          return cb(true);
        }
        return open(item, message, function(success, log) {
          if (!success) {
            return cb(false);
          }
          if (alreadyseenin(log)) {
            return sagalock.release(item.url, item.sagakey, function() {
              return cb(true);
            });
          }
          delete log.timeouts[item.timeoutkey];
          log.timeouttombstones[item.timeoutkey] = true;
          return commit(item, log, message, cb);
        });
      } else if (item.type === 'interval') {
        message = function(msg) {
          return "" + item.url + item.sagakey + " TIMEOUT " + item.intervalkey + "@" + (item.anchor.format(iso8601)) + " " + item.count + item.unit + "*" + item.value + " " + msg;
        };
        alreadyseenin = function(log) {
          if (log.intervaltombstones[item.intervalkey] != null) {
            console.log(message('TOMBSTONED'));
            return true;
          }
          if (log.interval[item.intervalkey].value >= item.value) {
            console.log(message('ALREADY SEEN'));
            return true;
          }
          return false;
        };
        isfutureevent = function(log) {
          if (log.interval[item.intervalkey].value + 1 < item.value) {
            console.log(message('FUTURE EVENT'));
            return true;
          }
          return false;
        };
        log = sagalog.getoutdated(item.url, item.sagakey);
        if (alreadyseenin(log)) {
          return cb(true);
        }
        if (isfutureevent(log)) {
          return cb(false);
        }
        return open(item, message, function(success, log) {
          if (!success) {
            return cb(false);
          }
          if (alreadyseenin(log)) {
            return sagalock.release(item.url, item.sagakey, function() {
              return cb(true);
            });
          }
          if (isfutureevent(log)) {
            return sagalock.release(item.url, item.sagakey, function() {
              return cb(false);
            });
          }
          log.intervals[item.intervalkey].value;
          log.intervaltombstones[item.intervalkey] = true;
          return commit(item, log, message, cb);
        });
      } else {
        console.log("Unknown task " + item.type + ". Ignoring...");
        return cb(true);
      }
    }
  });
  return {
    onmessage: function(url, sagakey, messagekey, e, cb) {
      return queue.enqueue({
        type: 'message',
        url: url,
        sagakey: sagakey,
        messagekey: messagekey,
        message: e,
        cb: cb
      });
    },
    ontimeout: function(url, sagakey, timeoutkey, value) {
      return queue.enqueue({
        type: 'timeout',
        url: url,
        sagakey: sagakey,
        timeoutkey: timeoutkey,
        value: value
      });
    },
    oninterval: function(url, sagakey, intervalkey, count, value) {
      return queue.enqueue({
        type: 'timeout',
        url: url,
        sagakey: sagakey,
        intervalkey: intervalkey,
        count: count,
        value: value
      });
    },
    drain: function(cb) {
      return queue.drain(cb);
    },
    destroy: function() {
      return queue.destroy();
    }
  };
};
