// Generated by CoffeeScript 1.9.2
var Queue, loghelper;

loghelper = require('./loghelper');

Queue = require('seuss-backoff');

module.exports = function(logwatcher, loglocker, options) {
  var handle, ontask, queue;
  ontask = options.ontask;
  queue = Queue({
    onitem: function(item, cb) {
      var instance;
      return instance = logwatcher.getinstancenow(item.url, item.sagakey, function(err, instance) {
        var interpreted, log;
        if (err != null) {
          console.log("MESSAGE " + item.url + item.sagakey + "." + item.messagekey + " " + item.message.msgid + " UNABLE TO LOAD");
          return cb(false);
        }
        log = instance != null ? instance.log : void 0;
        if (log == null) {
          log = [];
        }
        interpreted = instance != null ? instance.interpreted : void 0;
        if (interpreted == null) {
          interpreted = loghelper.blankinterpretedlog();
        }
        if (interpreted.handledmessages[item.message.msgid] != null) {
          console.log("MESSAGE " + item.url + item.sagakey + "." + item.messagekey + " " + item.message.msgid + " ALREADY SEEN");
          return cb(true);
        }
        return loglocker.acquire(item.url, item.sagakey, loghelper.stringify(log), function(success) {
          if (!success) {
            console.log("MESSAGE " + item.url + item.sagakey + "." + item.messagekey + " " + item.message.msgid + " COULD NOT LOCK");
            return cb(false);
          }
          log.push({
            type: 'handledmessage',
            id: item.message.msgid
          });
          return loglocker.release(item.url, item.sagakey, loghelper.stringify(log), function(success) {
            if (!success) {
              console.log("MESSAGE " + item.url + item.sagakey + "." + item.messagekey + " " + item.message.msgid + " UNABLE TO COMPLETE WRITE");
              return cb(false);
            }
            console.log("MESSAGE " + item.url + item.sagakey + "." + item.messagekey + " " + item.message.msgid + " WRITTEN TO LOG");
            return cb(true);
          });
        });
      });
    }
  });
  handle = logwatcher.onlog(function(url, instance) {});
  return {
    onmessage: function(url, sagakey, messagekey, e, cb) {
      return queue.enqueue({
        url: url,
        sagakey: sagakey,
        messagekey: messagekey,
        message: e,
        cb: cb
      });
    },
    ontimeout: function(url, sagakey, timeoutkey, value) {
      return console.log("TIMEOUT " + url + sagakey + "." + timeoutkey);
    },
    oninterval: function(url, sagakey, intervalkey, count, value) {
      return console.log("INTERVAL " + url + sagakey + "." + intervalkey);
    },
    drain: function(cb) {
      return queue.drain(cb);
    },
    destroy: function() {
      queue.destroy();
      return handle.off();
    }
  };
};
