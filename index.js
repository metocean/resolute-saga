// Generated by CoffeeScript 1.9.2
var async, bus, dispatcher, exittimeout, hub, loghelper, loglocker, logwatcher, resolute, sagainterval, sagatimeout, subscriptions, unifier;

logwatcher = require('./logwatcher');

loglocker = require('./loglocker');

loghelper = require('./loghelper');

resolute = require('resolute');

subscriptions = require('resolute/subscriptions');

dispatcher = require('./dispatcher');

unifier = require('./unifier');

sagatimeout = require('./sagatimeout');

sagainterval = require('./sagainterval');

hub = require('odo-hub/hub')(require('odo-hub/dispatch_parallel')());

logwatcher = logwatcher('docker:8500');

loglocker = loglocker('docker:8500');

sagatimeout = sagatimeout(logwatcher, {
  ontimeout: unifier.ontimeout
});

sagainterval = sagainterval(logwatcher, {
  oninterval: unifier.oninterval
});

bus = resolute({
  bind: 'tcp://127.0.0.1:12345',
  datadir: './12345'
});

subscriptions = subscriptions(bus);

dispatcher = dispatcher(subscriptions, hub);

unifier = unifier(logwatcher, loglocker, {
  ontask: dispatcher.ontask
});

subscriptions.bind('weather update', 'tcp://127.0.0.1:12346');

dispatcher.register('sagas/saga1/', require('./testsaga'));

logwatcher.watch('sagas/saga1/');

hub.every('message', function(e, cb) {
  return unifier.onmessage('sagas/saga1/', 'exe1', 'message', e, cb);
});

async = require('odo-async');

async.delay(function() {
  hub.emit('message', {
    msgid: 1,
    value: 'awesome'
  });
  return hub.emit('message', {
    msgid: 2,
    value: 'awesome'
  });
});

exittimeout = null;

process.on('SIGINT', function() {
  var close, exit;
  close = function() {
    clearTimeout(exittimeout);
    unifier.destroy();
    bus.close();
    logwatcher.destroy();
    loglocker.destroy();
    sagatimeout.destroy();
    return sagainterval.destroy();
  };
  exit = function() {
    close();
    return process.exit(0);
  };
  if (exittimeout != null) {
    exit();
  }
  exittimeout = setTimeout(exit, 10000);
  console.log('Waiting for queues to empty.');
  console.log('(^C again to quit)');
  return dispatcher.end(function() {
    return bus.drain(close);
  });
});
